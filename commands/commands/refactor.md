# 智能重构引擎 - Trae版本

我将帮助你系统地重构代码 - 保留功能的同时改进结构、可读性和可维护性。

参数：`$ARGUMENTS` - 文件、目录或重构范围

**关键特性：每次更改后内置验证和优化，确保没有任何破坏，没有遗留代码。AI会在重构过程中自动修复自己的错误。**

**会话文件位置：始终使用当前目录中的refactor/文件夹**

## 会话智能

我将在会话间保持重构连续性：

**会话文件（在当前项目中）：**
- `refactor/plan.md` - 带进度跟踪的重构计划
- `refactor/state.json` - 当前状态和已完成操作

**重要提示：** `refactor`文件夹在你的当前项目目录中创建。使用`refactor/`访问它。

**自动检测：**
- 如果会话存在：从最后检查点恢复
- 如果没有会话：创建新的重构计划
- 命令：`resume`、`continue`、`status`、`new`

**正确路径使用示例：**
```
# 正确 - 在当前项目中查找：
view_files refactor/state.json
list_dir refactor

# 错误 - 这些会失败：
view_files ../../../refactor/state.json
view_files $HOME/.claude/refactor/state.json
```

## 阶段1：初始设置和分析

### 复杂重构的扩展思考

对于复杂的重构场景，我会使用扩展思考来制定全面策略：

<think>
面对复杂的架构重构时：
- 保持功能的多步转换路径
- 每个转换的风险缓解策略
- 依赖图分析和更新顺序
- 不同方法的性能影响
- 向后兼容性要求
- 验证每个步骤的测试策略
</think>

**扩展分析的触发条件：**
- 大规模架构更改
- 复杂依赖解耦
- 性能关键重构
- 遗留系统现代化

**会话检查的强制第一步：**
```
步骤1：检查当前目录中的refactor目录
命令：list_dir refactor

步骤2：如果refactor存在，读取会话文件：
命令：view_files refactor/state.json
命令：view_files refactor/plan.md

不要使用这些错误路径：
- ../../../refactor/  (错误 - 向上查找目录)
- $HOME/refactor/  (错误 - 主目录)
- ~/refactor/  (错误 - 主目录)

只使用：refactor/ (当前目录)
```

**关键：** refactor文件夹在用户运行命令的当前工作目录中创建。不在主目录，不在父目录。

我将检查你的代码库以识别改进机会：

**分析重点：**
- 使用**search_by_regex**模式的代码复杂度热点
- 跨文件的重复检测
- 架构不一致性
- 安全重构的测试覆盖率
- 性能瓶颈

**智能范围界定：**
- 如果提供特定文件：重点分析
- 如果提供目录：递归分析
- 如果没有参数：战略性项目范围扫描

## 阶段2：重构规划

基于分析，我会创建结构化计划：

**重构类别：**
- **快速胜利**：变量重命名、方法提取
- **结构性**：模式应用、依赖改进
- **架构性**：主要重组、模块边界
- **性能**：算法优化、缓存策略

**计划结构：**
我会在`refactor/plan.md`中创建详细计划：

```markdown
# 重构计划 - [时间戳]

## 初始状态分析
- **当前架构**: [现有模式描述]
- **问题区域**: [发现的具体问题]
- **依赖关系**: [外部/内部依赖]
- **测试覆盖率**: [当前覆盖率%]

## 重构任务
[按风险级别优先排序的列表]

## 验证清单
- [ ] 所有旧模式已移除
- [ ] 没有破坏的导入
- [ ] 所有测试通过
- [ ] 构建成功
- [ ] 类型检查清洁
- [ ] 没有孤立代码
- [ ] 文档已更新

## 对照映射
| 之前 | 之后 | 状态 |
|------|------|------|
| OldService.method() | NewService.method() | 待处理 |
| /api/v1/* | /api/v2/* | 待处理 |
```

## 阶段3：增量执行

我将系统地应用重构：

**执行顺序：**
1. 创建git检查点以确保安全
2. 首先应用低风险改进
3. 每次更改后验证
4. 进展到更高影响的重构
5. 用完成状态更新计划

**持续验证和优化：**
每次重构更改后：
1. **即时测试：**
   - 为修改的文件运行单元测试
   - 如果适用，执行集成测试
   - 验证没有测试回归
   
2. **深度比较：**
   - 比较前后函数输出
   - 验证API契约保持
   - 检查遗漏的边缘情况
   - 验证错误处理保留
   
3. **自动修复：**
   - 自动更新破坏的导入
   - 修复引用错误
   - 调整类型定义
   - 解决linting问题
   
4. **质量门：**
   - 如果测试失败则停止 - 立即修复
   - 如果行为改变则停止 - 调查
   - 如果性能下降则停止 - 优化
   - 只有在100%验证后才继续

5. **持续优化：**
   - 重新扫描遗漏的模式
   - 更新所有相关文件
   - 清理孤立代码
   - 记录破坏性更改

## Trae使用示例

```bash
# 1. 检查现有重构会话
list_dir refactor

# 2. 如果存在，读取状态
view_files refactor/state.json
view_files refactor/plan.md

# 3. 分析代码复杂度
search_by_regex "function.*{[\s\S]{200,}" # 查找长函数
search_codebase "重复的代码模式"

# 4. 创建重构计划
write_to_file refactor/plan.md "重构计划内容"

# 5. 执行重构
update_file "重构特定文件"

# 6. 验证更改
run_command "npm test" # 或其他测试命令

# 7. 更新状态
update_file refactor/state.json "更新进度"
```

## 重构模式

**常见重构操作：**
- 提取方法：将长函数分解为小函数
- 提取变量：为复杂表达式命名
- 内联方法：移除不必要的间接层
- 移动方法：将方法移到更合适的类
- 重命名：改进变量、函数、类名
- 消除重复：合并相似代码

**架构重构：**
- 分层架构：分离关注点
- 模块化：创建独立模块
- 依赖注入：减少耦合
- 设计模式：应用适当模式